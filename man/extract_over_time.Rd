% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/extract_over_time.R
\name{extract_over_time}
\alias{extract_over_time}
\title{Extract values from a raster over time}
\usage{
extract_over_time(
  x,
  r,
  subds = 0,
  temporal_fun = function(x) {
     rowMeans(x, na.rm = TRUE)
 },
  spatial_extraction_fun = function(x, r, ...) {
     extract_over_space(x = x, r = r,
    ...)
 },
  scale = NULL,
  time_buffer = lubridate::days(0),
  debug = FALSE,
  override_terraOptions = TRUE,
  time_column_name = NULL,
  is_vectorised_summarisation_function = FALSE,
  verbose = TRUE,
  trim_raster = TRUE,
  subset_raster_indices = TRUE,
  ...
)
}
\arguments{
\item{x}{A \code{sf} collection with a geometry column and a time column.}

\item{r}{A file path to a raster file or a SpatRaster object from the terra
package. This is the raster data.
source from which the data will be extracted.}

\item{subds}{positive integer or character to select a sub-dataset to extract
from. If zero or "", all sub-datasets are extracted.}

\item{temporal_fun}{A function used to summarise multiple data points
found within a time interval. Default is \code{rowMeans(x, na.rm=TRUE)}. The user
can supply vectorised summarisation functions (using rowMeans or rowSums) or
non-vectorised summarisation functions (e.g., \code{sum}, \code{mean}, \code{min}, \code{max}).
If supplying a custom vectorised \code{temporal_fun}, set
\code{is_vectorised_temporal_fun} to \code{TRUE} to ensure the vectorised approach is
used for performance. Note, vectorised summarisation functions are not
possible when \code{fun=NULL} and you are extracting with polygon or line
geometries (i.e. \code{temporal_fun} is used to summarise, treating each time and
space value independently).}

\item{spatial_extraction_fun}{A function used to extract points spatially for
each time slice of the raster. Default is the default implementation of
\code{extract_over_space} (extracts the \code{mean} of geometries within rasters,
removing NAs).}

\item{scale}{The scale to aggregate your raster to (in units of the
original raster). Note this will be rounded to fit the nearest aggregation
factor (number of cells in each direction). Leave as NULL (the default) if
you do not want any aggregation. See \link[terra]{aggregate}.}

\item{time_buffer}{Time buffer used to adjust the time interval for data
extraction. The function always uses the time before and after the interval
to prevent errors when summarising the earliest and latest times. Default is
0 days.}

\item{debug}{If TRUE, pauses the function and displays a plot for each
extracted point. This is useful for debugging unexpected extracted values.
Default is FALSE.}

\item{override_terraOptions}{If TRUE, overrides terra's default terraOptions
with those specified in the envfetch's package. Default is TRUE.}

\item{time_column_name}{Name of the time column in the dataset. If NULL (the
default), a column of type lubridate::interval is automatically selected.}

\item{is_vectorised_summarisation_function}{Whether the summarisation is
vectorised (like rowSums or rowMeans). Is only necessary to be TRUE if the
row-wise vectorised summarisation function has not been automatically
detected (does not use rowSums or rowMeans).}

\item{verbose}{Whether to print messages to the console. Defaults to TRUE.}

\item{trim_raster}{Whether to trim the raster to time bounds as a performance
optimisation. Defaults to TRUE.}

\item{subset_raster_indices}{Whether to subset raster by time indices as a
performance optimisation. Defaults to TRUE.}

\item{...}{Additional arguments to pass to the \code{spatial_extraction_fun}.}
}
\value{
A modified version of the input 'x' with additional columns
containing the extracted data.
}
\description{
This function extracts raster data over time ranges of each row and
summarises the extracted data using a custom function. The function
summarises this information for each row in your dataset (\code{x}). This function
is best used within the \code{fetch} function.
}
\examples{
\dontrun{
extracted <- d \%>\%
  fetch(
    ~extract_over_time(.x, r = '/path/to/netcdf.nc'),
  )

# extract and summarise data every fortnight for the past six months
# relative to the start of the time column in `d`
rep_extracted <- d \%>\%
  fetch(
      ~extract_over_time(.x, r = '/path/to/netcdf.nc'),
      .time_rep=time_rep(interval=lubridate::days(14), n_start=-12),
  )
}
}
